对于输出流来讲，有些同学可能会说，因为close()方法里有writebyte()功能，不关闭不能写入。

但是对于输入流，比如inputStream,不关闭输出的内容也会被读取存在JVM中，为什么需要关闭呢？再者，为什么gaosling一定要把writebyte在close方法里呢？

这是因为：
需要自己close的东西，一般都是用了虚拟机之外的资源，例如端口，显存，文件等，虚拟机无法通过垃圾回收释放这些资源，只能你显式调用close方法来释放。

许多情况下，如果在一些比较频繁的操作中，不对流进行关闭，很容易出现输入输出流经 超越了JVM的边界 ，所以有时可能无法回收资源。所以流操作的时候 凡是跨出虚拟机边界的资源都要求程序员自己关闭，不要指望垃圾回收。

你读一个文件，忘记关闭了流，你在操作系统里对这个文件的写，删除等操作就会报错，告诉你这个文件被某个进程占用。
