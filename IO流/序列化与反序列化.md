(https://blog.csdn.net/mocas_wang/article/details/107621010)推荐文章

序列化这个词看着很高大上，其实本质还是数据，只不过存储的数据不是文本，视频，音乐，而是为Java使用的数据，比如类的实例。

当我们编写了一个类，将这个类的实例序列化之后存储在一个```.dat```文件中时,如果我们更改类的源码，比如增加了一个方法，我们反序列化时会报错，这是为啥呢？

1. 这是由于新旧两个类的的 serialVersionUID 不一致导致的。
2. serialVersionUID 是控制类的版本兼容的，如果不在类中显式定义该属性，Java 会根据类的细节自动生成该属性的值。
3. 所以如果对类进行了修改，再重新编译，生成的新的 .class 文件中的 serialVersionUID 很可能会发生变化。
4. 反序列化时，会检查序列化文件中的保存的 serialVersionUID 与当前本地类的 serialVersionUID 是否一致，若一致则可视为兼容的，不会抛出异常。 否则认为是不兼容的，
   抛出异常，序列化文件中老的 serialVersionUID 对应的数据相当于被抛弃，无法再恢复

解决方法：
重新序列化

此外，还有一个问题很少有人思考，我讨论一下：

```
问：在Java中，一个类a在包A下面，一个类b在包B下面，a里面并且通过序列化将一个a实例存入一个文件，
    类b想通过反序列化通过文件c获得a的实例，请问b必须要引入a类吗
```

答（from chatGpt）：

在Java中，如果类 b 需要通过反序列化来获得类 a 的实例，那么 b 必须要引入类 a。这是因为在进行反序列化时，Java需要知道被序列化对象的确切类信息，以便正确地恢复对象的状态。这包括了对象的类名、字段等信息。

如果 b 想要反序列化从文件中读取的 a 的实例，它需要满足以下条件：

类 a 必须在类路径（classpath）中可用。这意味着类 b 需要能够访问类 a 的字节码或类文件。这通常是通过将类 a 编译为字节码文件并与类 b 放在相同的类路径下来实现的。

类 b 必须包含 import 语句或其他方式来引入类 a，以便在代码中访问类 a。
