本节记录一下位运算符和位运算的规则：



```java
public class BitOperator { 

	//编写一个main方法
	public static void main(String[] args) {

		//1. 先得到 2的补码 => 2的原码 00000000 00000000 00000000 00000010
		//   2的补码 00000000 00000000 00000000 00000010
		//2. 3的补码 3的原码 00000000 00000000 00000000 00000011
		//   3的补码 00000000 00000000 00000000 00000011
		//3. 按位&
		//   00000000 00000000 00000000 00000010
		//   00000000 00000000 00000000 00000011 
		//   00000000 00000000 00000000 00000010 & 运算后的补码
		//   运算后的原码 也是  00000000 00000000 00000000 00000010
		//   结果就是  2
		System.out.println(2&3);//2

		//推导
		//1. 先得到 -2的原码 10000000 00000000 00000000 00000010
		//2. -2的 反码 	    11111111 11111111 11111111 11111101
		//3. -2的 补码       11111111 11111111 11111111 11111110
		//4. ~-2操作        00000000 00000000 00000000 00000001运算后的补码
		//5. 运算后的原码 就是 00000000 00000000 00000000 00000001 => 1
		System.out.println(~-2);//1

		//推导
		//1. 得到2的补码(正数三码合一) 00000000 00000000 00000000 00000010
		//2. ~2操作     11111111 11111111 11111111 11111101  运算后的补码
		//3. 运算后的反码（补码-1）  11111111 11111111 11111111 11111100
		//4. 运算后的原码（符号位不变，其他位取反）  10000000 00000000 00000000 00000011=>-3
		System.out.println(~2); //-3
	}
}
```

另外一个知识点我觉得也是很有必要记录的，负数的算术右移\左移：

```java
public class test{
	public static void main(String[] args){
		byte a = -1;
		a = (byte)(a >> 1);//!!算术右移也是运算符，也遵循多格式变量运算时转化为精度最高的那个，所以也需要强制类型转换。
		//a 的源码为 10000001
		//a 的反码为符号位不变，其他位取反：11111110
		//计算机以补码操作，反码+1变为补码：11111111：算术右移一位，符号位不变，用符号位补溢出的高位：11111111
		//补码-1转换为反码:11111110，符号位不变，其他位取反转化为原码：10000001，根据格式应该是：-1；
		System.out.println(a);
	}

}
```



