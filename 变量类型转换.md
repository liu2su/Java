## 变量类型转换

我遇到的一个关于变量的问题：
**java中long=后面为什么还要加个L**

从这个问题做切入口，谈谈Java自动转型机制和声明变量的方法。先回答上面的问题：因为JAVA的整型常量默认为int类型 ，浮点数为double类型，声明long型常量需要需要后加L或l

举个例子：
```java
int a = 4; 
/*
这里的‘4’就是上面说的整型常量，默认类型为int,所以当4赋值给一个int类型的变量a时，编译通过。
在Java中，变量的类型必须与所赋的值的类型匹配。在这种情况下，将一个长整型值（4L）赋给一个整型变量（int a）会导致编译错误。
*/
```

从这里我们就开始学习一些所谓**底层原理**了，对于变量转换,核心是**两条线，6个要点**：
## 两条线

![两条线](https://github.com/liu2su/Java-SEnote/assets/96462566/d5dd8b2b-8c69-4213-9730-ced5bdc555b4)

这张图片代表了Java变量关系中的**自动类型转换**的原理，总的来讲就是低精度的常量值付给高精度的变量时，常量值类型自动转换为变量代表的类型。类型下的红色数字代表占据空间的大小，单位为byte。

这里可能有个疑问,long类型是8字节，为什么可以转换为float呢？ 这里就涉及到浮点数在内存中的存储问题了。对于byte，short，int，long四个整数类型而言，它们在内存中无一例外都是直接换算成二进制存储的，所以我们可以直接计算出它们的最大值。float类型,4个字节，32位，第1位是符号位（数符），即S，接下来的8位是指数域（阶码），即E，最后的23位，是小数域（尾数），即M。简单来说因为浮点数用科学计数法存储的，而整数是用二进制存储的。所以虽然long型是64位的，float型是32位，但是float型所能表示的数要远远大于long型。

## 六个要点

- 第1个要点：多种类型混合运算，系统首先自动将所有数据转换成容量最大的数据类型，然后计算。
  ```java
  int n1 = 10;
  double n2 = 1.1;
  float n3 = n1 + n2;//报错，因为n1 + n2 该数据的类型为double，无法赋予类型为float的变量
  ```
- 第2个要点：当我们把精度（容量）大的数据类型赋值给精度小的数据类型时，会报错，反之则会自动类型转换。（小转换到大）
  ```java
  //特例：隐含强制类型转换
  short a = 1;
  byte b = 1;
  //这样是可以的，因为虽然int是常量的默认类型，但是在自动转换之前还会执行一个机制：先判断该值是否在变量short,byte范围内，如果是则正常赋值（只有被赋值的变量类型是byte和short才会这么做，char也会有一个类似的判断，所以char也可以直接复制整数）。
  int a  = 1;
  b = a;//这样就会报错，因为这个是变量赋值，不是常量赋值，不适用上面的规则
  ```
- 第3个要点：（char,shot）与char之间不会自动转换
  ```java
  char a = 10;
  short b = a;//报错，因为要点3
  ```
- 第4个要点：byte,short,char之间可以互相计算，计算时首先转换为int类型，比如以下面试题：
  ```java
  byte n1 = 1;
  short n2 = 3;
  short n3 = n1 + n2 //这行会报错
  ```
  因为n1 + n2 在运算时被提升为int类型（因为两个byte相加可能会超过byte范围），int类型精度大于short,不能自动转换，所以会报错。注意和要点1的区分，当这三种变量和其他类型混合运算时，转换为数据中容量最大的，即遵守要点1，只有这三种类型混合运算时，遵守要点4.
  
- 第5个要点：boolean不参与转换
- 第6个要点：自动提升原则，表达式的结果类型自动提升为操作数中的最大类型

