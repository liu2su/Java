在学习完代码块和静态成员后，我对创建object的过程有了疑惑，为了解答我的疑惑，我创建了如下代码： B继承A

```java
package test;

public class Test2 {
    public static void main(String[] args) {

        B b = new B();
    }
}

class A{
    static{
        System.out.println("父类A的静态代码块");
    }

    {
        System.out.println("父类A的普通代码块");
    }
    public int a = initA();
    public static int aa = initAA();
    public A(){
        System.out.println("父类A的构造器");
    }
    public int initA(){
        System.out.println("父类A的field显示初始化");
        return 1;
    }
    public static int initAA(){
        System.out.println("父类A的静态变量初始化");
        return 1;
    }
}
class B extends A{
    static{
        System.out.println("子类B的静态代码块");
    }

    {
        System.out.println("子类B的普通代码块");
    }
    public int b = initB();
    public static int bb = initBB();
    public B(){
        System.out.println("子类B的构造器");
    }

    public int initB(){
        System.out.println("子类B的field显示初始化");
        return 2;
    }

    public static int initBB(){
        System.out.println("子类B的静态变量初始化");
        return 1;
    }
}
```

输出结果：
```
父类A的静态代码块
父类A的静态变量初始化
子类B的静态代码块
子类B的静态变量初始化
父类A的普通代码块
父类A的field显示初始化
父类A的构造器
子类B的普通代码块
子类B的field显示初始化
子类B的构造器
```

注：
1. 注意代码块和字段同优先级，谁写在前面先执行谁。
2. 构造器implicit statement：
   ```
   constructor(){
      //super
      // normal codeblock
   }
   ```
3. 方法区是JVM内存模型中的一个区域，用于存储类相关的信息，如类名、类的访问修饰符、字段信息、方法信息、常量池等。
